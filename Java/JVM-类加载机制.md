# 1.简述一下JVM的类加载机制
1. 虚拟机把描述类的数据从Class文件加载到内存，并对其进行校验、解析和初始化，最后形成可以被JVM直接使用的Java类型，这个过程就是类加载。
2. 在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。
Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。
3. 类加载经过加载、验证、准备、解析和初始化五个阶段，类的加载过程必须按部就班的就行，而解析阶段则不一定，一定情况下可以在初始化之后才开始（JVM规范没有强制规定）
4. 加载阶段虚拟机完成下面几件事情：
* 通过类的全限定名来获取次此类的二进制字节流
* 将字节流的静态存储结构转化为方法区的运行时数据结构
* 内存中生成一个对应的java.lang.Class对象，作为方法区这个类的数据的访问入口
* 相较于类加载过程的其他阶段，加载阶段可控性是最强的，因为这个阶段你既可以使用系统提供的引导类加载器完成，也可以自定义类加载器完成，去控制字节流的获取方式（比如通过jar，网络，反射）
5. 验证阶段：确保Class文件的字节流包含信息符合JVM的要求
* 文件格式验证：字节流是否符合Class文件格式的规范（魔数，版本区间）
* 元数据验证：对字节码描述的信息进行语义分析，保证符合Java语言规范的要求
* 字节码验证：最复杂阶段，通过数据流和控制流分析，确定程序语义是合法，符合逻辑的
* 符号引用验证：在解析阶段发生，对类自身以外的信息进行匹配性校验。
6. 准备阶段：正式为类变量分配内存并设置类变量初始值（指的是数据类型的零值）
7. 解析阶段：将常量池的符号引用替换为直接引用的过程
* 符号引用：用一组符号描述所引用的目标，符号可以是任何形式字面量，只要无歧义找到目标。符号引用与JVM的内存布局无关，引用目标不一定已经加载到内存中。（字面量形式定义在JVM规范中）
* 直接引用：可以是指向目标的指针、偏移量或者句柄。与内存相关且引用目标必定存在于内存
7. 初始化阶段：真正开始执行类中定义的Java程序代码（或者说是字节码），按照主观计划去初始化类变量和其他资源
8. 除了加载阶段用户可以通过自定义类加载器参与之外，其他阶段都由JVM主导和控制。


# 2.类初始化阶段的时机
1. 遇到new、getstatic、putstaic字节码时候，比如new实例化对象的时候、读取或者设置类的静态字段，调用静态方法时候。
2. 使用reflect包对类进行反射操作的时候，如果没有初始化需要先初始化。
3. 初始化一个类时，他的父类还没有初始化。
4. JVM启动时候，用户需要指定一个启动的主类（包含main()的类）
5. 当使用JDK1.7的动态语言支持时候。

# 3.类加载器是什么？什么是双亲委派模型？
1. 用来实现加载阶段通过类的全限定名来获取此类描述的二进制字节流需求，这个动作JVM是交由外部执行的。
2. 从Java开发人员角度看，类加载器分为三种：
* 启动类加载器（Bootstrap ClassLoader）:这个类加载器负责将<JAVA_HOME>\lib目录下的类库加载到内存中，就是内置类。无法被Java程序直接引用
* 扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录中的（继承类和实现类），开发者可以使用
* 应用程序加载器（Application ClassLoader）:负责加载用户类路径上（ClassPath）上指定的类库，如果程序中没有自定义过自己类加载器，这个就是默认的类加载器了。
3. 类加载器之间的层次关系称为双亲委派模型
![image](http://img.blog.csdn.net/20170625231013755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
* 要求除了顶层的启动类加载器之外，其余类加载器都要有自己的父类加载器，这里使用组合关系来复用父类加载器而非继承。
* 如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器完成，每一层都是如此，因此所有加载请求最终都会传到启动类加载器，只有当父类反馈自己无法完成时候，子类加载器才会自己尝试。
* 好处是Java类随着它的类加载器一起具备了优先级的层次关系，利于保证Java程序的稳定运作（避免出现多个不同的Object类，因为Java中判定两个类是否相等，必须是来源于同一个Class文件且被同一个类加载器加载）