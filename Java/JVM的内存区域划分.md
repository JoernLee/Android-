# 1.JVM的内存区域有哪几个区？每个区的作用是什么？
1. JVM内存划分为程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。
* 程序计数器：当前线程执行字节码的行号显示器，过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。此内存区域唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。
* Java虚拟机栈：虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。
* 本地方法栈：本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。
* Java堆：ava堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例以及数组都在这里分配内存，因此该区域经常发生垃圾回收操作。
* 方法区：方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
![image](http://img.blog.csdn.net/20170718214807190?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhb21pbmdkZXRpYW54aWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

# 2.哪些区域是线程私有？哪些是线程共享？
* 程序计数器、Java虚拟机栈本地方法栈是线程私有
* Java堆和方法区是线程共享

# 3.描述一下各个区域有哪些异常？有哪些原因导致？
1. 程序计数器区域是唯一不存在OOM的区域
2. Java虚拟机栈
* 存在StackOverflowError异常：请求的栈的深度大于虚拟机允许的深度
* 存在OutOfMemoryError异常：虚拟机动态扩展时无法申请到足够内存。
3. 本地方法栈类似虚拟机栈
4. Java堆
* OOM异常：堆中没有内存完成实例分配且堆也无法扩展
5. 方法区
* OOM异常：无法满足内存分配需求。

# 4.请讲讲直接内存和NIO类
1. 直接内存并不是虚拟机运行时数据区的一部分，但是也被频繁使用，也称堆外内存。
2. Java可以通过NIO类，使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆的DirectByteBuffer对象作为这块引用来操作。
3. DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制。
4. 直接内存的读写操作比普通Buffer快，但它的创建、销毁比普通Buffer慢。因此直接内存使用于需要大内存空间且频繁访问的场合，不适用于频繁申请释放内存的场合。


# 5.方法区为什么有时候叫作永久代？现在有变化吗？
1. 绝大部分 Java 程序员应该都见过 "java.lang.OutOfMemoryError: PermGen space "这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。
2. 在JDK1.8中，HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 。
3. 移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap
4. 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小

# 6.JVM的方法区实现为什么要用元空间替代
* 字符串存在永久代中，容易出现性能问题和内存溢出。
* 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
* 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
* Oracle 可能会将HotSpot 与 JRockit 合二为一。

# 7.简单说一下一个对象的创建过程。
1. 虚拟机遇到new指令，首先检查该指令参数是否能在常量池定位到一个类的符号引用并且检查这个类是否被加载，解析，初始化。如果没有先执行类加载。
2. 接下来为新生对象分配内存，对象所需内存大小在类加载完之后就确定了。之后根据Java堆是否规整，选择采用指针碰撞或者空闲列表的分配方式来把需要的内存从堆中划分出来。
3. 内存分配完成后，将分配到的空间初始化零值，保证对象不赋初始值也可以使用。
4. 紧接着JVM对对象进行必要设置，比如哪个类的实例，哈希码，GC年代信息等等，放在对象的头之中。
5. 上面工作完成之后，从JVM角度看，新的对象已经诞生。下面就是从程序角度进行初始化了和其他操作了。
