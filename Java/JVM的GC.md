# 1.GC怎么识别垃圾、其他语言是怎么管理内存的，和java有什么区别？
1. GC识别垃圾的算法：引用计数算法和可达性分析算法。

引用计数器：通过一个引用计数器去标志对象的被引用数。

可达性分析算法：利用一系列称为GCRoots的对象为起始点，向下搜索。当一个对象到GCRoots没有任何引用链（路径）时候，该对象不可用。
2. C++中没有垃圾收集技术，在内存管理领域，拥有每一个对象的所有权，又担负着每一个对象从生命开始到终结的维护责任。Java有动态内存分配和垃圾收集技术，借助JVM完成无用对象释放，而且不容易出现内存泄露和内存溢出问题。
3. C++经过编译时直接编译成机器码，而Java是编译成字节码，由JVM解释执行。


# 2.什么可以作为GCRoots
* 虚拟机栈中引用的对象（栈帧中的本地变量表）
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象


# 3.新生代老年代的收集算法
三种算法使用常见：标记-清除算法、复制算法以及标记-整理算法。
2. 标记-清除算法：最基础收集算法，标记出需要回收对象并在标记完成后统一回收。存在效率问题和空间碎片问题。
3. 复制算法：将内存划分为两块，每次只用一块，当一块内存满了，将存活对象复制到另外一块上面，不用考虑内存碎片。比如虚拟机的一块Eden空间和两块Survior空间配合使用。
4. 标记-整理算法：标记过程同前面一样，但是不是直接清理，而是让所有存活对象向一端移动，然后清理边界以外的内存

# 4.新生代为什么用复制算法
1. 新生代的MinorGC触发比较频繁，所有必须选择效率较高的收集算法，这里相比标记-整理两步走来说复制算法快得多，且经过优化的复制算法利用Eden/S0/S1的组合运用和老年代的分配担保也可以保证一定的空间利用率。
2. 老年代一般用标记-整理算法，一方面因为FullGC不频繁，另一方面因为复制算法需要额外空间分配担保以应对内存对象100%存活的极端情况，适合标记-整理算法。

# 5.老年代担保是什么？
1. 针对新生代使用的复制算法，如果Survior空间不够存放新生代收集下来的存货对象的时候，就需要依赖老年代的空间了。
2. 前提是老年代本身拥有容纳这些存活对象的空间，这里取每一次晋升到老年队对象容量的平均大小作为经验值和老年代剩余空间比较，决定是否进行FullGC让老年代腾出空间。

# 6.在不考虑循环引用的前提下：引用计数法和可达性分析的性能比较？
1. JVM没有使用引用计数法，而是使用了可达性分析来进行GC。C++11的智能指针就是基于引用计数的，它提供了weak_ptr来解决循环引用的问题。（类似于Java中的WeakReference，作用类似）
2. 不考虑循环引用情况下引用计数法实现比较简单也快速，能够立即释放内存，而可达性分析必须进行一遍可达性判定才行。
3. 先用引用计数处理绝大多数对象回收，少数循环引用的对象先放在那儿，等积累较多，占用内存比较大的时候，再用可达性算法再来清除一次，这样既能快速回收垃圾，又解决了循环引用的问题。---python就是这样



# 7.GC一般的触发条件？发生在何时
1. Java的GC分为FullGC和MinorGC。
2. MinorGC的触发条件：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。
3. FullGC的触发条件包括：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。


# 8.GC针对的对象？
1. 利用可达性分析算法从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。 

# 9.GC是如何进行的？
1. 新生代使用复制算法进行GC，老年代通常采用标记-整理或者清理算法进行GC。
2. 具体实现还需要依赖收集器。
3. ，还能讲清楚串行、并行（整理/不整理碎片）、CMS等搜集器可作用的年代、特点、优劣势，并且能说明控制/调整收集器选择的方式。就更好了 

# 10.Java中的四种引用概念？
1. 强引用：类似Object obj = new Object（）;这种，垃圾收集器不会回收这种对象。
2. 软引用：描述一些有用但非必需对象，将要发生OOM异常时候会对这些对象进行二次回收。
3. 弱引用：只能生存到下一次GC之前
4. 虚引用：一个对象是否有虚引用，完全不会对生存时间造成影响，存在目的就是对象被GC时候可以收到系统通知。

# 11.你所了解的内存分配规则和策略
1. 对象优先在Eden分配：对象大多数情况下在Eden区分配，若Eden区域不足，会执行一次MinorGC
2. 大对象直接进入老年代：需要大量连续空间的对象直接进入老年代，阈值由PretenureSizeThreshold参数控制，避免大量的内存复制。
3. 长期存活对象进入老年代：利用年龄计数器进行年龄计算，多次MinorGC后仍然能够被Survior容纳的话就晋升到老年代，通过MaxTenuringThreshold参数控制。
4. 动态对象年龄判断：并非年龄计数器必须达到阈值才能晋升，如果在S空间中相同年龄所有对象大小和大于S空间一半，那么年龄大于等于此的对象就可以晋升。
5. 空间分配担保：前面已经详细说过

# 12.被可达性分析或者引用计数法标记为无用对象后就一定会被GC回收吗？
1. 不是的，一个对象的死亡至少要经历两次标记过程
2. 如果对象被标记为可回收对象，那他将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行方法”。（这也是为什么大家不鼓励重写finalize方法的原因之一）
3. 对象判断为有必要执行finalize（）方法，那么这个对象会放到一个叫做F-Queue队列中，并在稍后一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它，这里的执行只是负责触发这个方法，并不一定等这个方法执行结束。inalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可（这里描述的是可达性分析算法，因为虚拟机几乎都不采取引用计数法）。比如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那么在第二次标记时他将被移除出“即将回收”的队列；若对象这时候还没有逃脱，那么基本上真的就要被回收了。

# 13.你所了解的JVM中的垃圾收集器有哪些？
1. 截止JDK1.7，JVM包括了Serial和SerialOld、ParllelScavenge和ParellelOld、ParNew和CMS以及G1垃圾收集器
2. Serial和SerialOld是分别针对新生代和老年代的单线程收集器，他的特点就是简单高效，对于限定单个CPU环境下没有线程交互开销，用于运行于Client模式下的虚拟机
3. ParNew收集器是Serial收集器的多线程版本，目前只有它能够和CMS配合工作。
4. ParallelScavenge和ParallelOld收集器配合使用，他的特点是关注吞吐量而非尽可能缩短垃圾收集时候的停顿时间。停顿时间影响用户体验，而吞吐量影响工作效率，适用于后台运算任务。
5. CMS收集器是以最短回收停顿时间为目标的收集器，适合互联网站或者B/S系统服务端，重视服务响应速度。CMS基于标记-清楚算法，运作分为四个步骤：初始标记，并发标记，重新标记，并发清除。CMS有三个明细缺点：
* 并发阶段占用线程导致工作线程减少，程序变慢。
* 无法处理浮动垃圾（并发清理时产生的垃圾）
* 标记-清除算法带来的空间碎片
6. G1收集器：
